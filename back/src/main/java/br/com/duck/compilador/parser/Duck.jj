/*@bgen(jjtree) Generated By:JJTree: Do not edit this line. Duck.jj */
/*@egen*/options
{
  static = true;
}

PARSER_BEGIN(Compilador)

package br.com.duck.compilador.parser;
import br.com.duck.compilador.recovery.*;

public class Compilador/*@bgen(jjtree)*/implements CompiladorTreeConstants/*@egen*/
{/*@bgen(jjtree)*/
  protected static JJTCompiladorState jjtree = new JJTCompiladorState();

/*@egen*/
  public static void main(String args []) throws ParseException
  {
    Compilador parser = new Compilador(System.in);
    while (true)
    {
      System.out.println("QUACK QUACK FALA A BOA: \n- >");

	  SimpleNode node = Compilador.Start();
      node.dump(" ");
      
      try
      {
        //Compilador.Start();
      }
      catch (Exception e)
      {
        System.out.println("Erro de quckila\u00e7\u00e3o: ");
        System.out.println(e.getMessage());
        Compilador.ReInit(System.in);
      }
      catch (Error e)
      {
        System.out.println("Erro quacktal: ");
        System.out.println(e.getMessage());
        break;
      }
    }
  }

  static public String im(int x)
  {
    int k;
	String s;
    s = tokenImage[x];
    k = s.lastIndexOf("\"");
    try {
      s = s.substring(1,k);
    }
   catch (StringIndexOutOfBoundsException e)
	   {}
   return s;
  }
	
  static Token lastError = null;
  static boolean eof;    // vari\u00e1vel que indica se EOF foi alcan\u00e7ado
	
  // o m\u00e9todo abaixo consome tokens at\u00e9 alcan\u00e7ar um que perten\u00e7a ao conjunto
  // de sincroniza\u00e7\u00e3o
  static void consumeUntil(RecoverySet g,
	                 ParseException e,
	                 String met) throws ParseEOFException,
	                                    ParseException
  {
	Token tok;
	System.out.println();
	System.out.println("*** " + met + " ***");
	System.out.println("     Conjunto de sincroniza\u00e7\u00e3o: " + g);
		
	if (g == null) throw e; // se o conjunto \u00e9 null, propaga a exce\u00e7\u00e3o
	
	tok = getToken(1); // pega token corrente
	while ( ! eof )	{ // se n\u00e3o chegou ao fim do arquivo
	  if ( g.contains(tok.kind)) {//achou um token no conjunto
	    System.out.println("     Encontrado token de sincroniza\u00e7\u00e3o: " + 
	                       im(tok.kind));
	    break;
	  }
	  System.out.println("     Ignorando o token: " + im(tok.kind));
	  getNextToken();     // pega pr\u00f3ximo token       
      tok = getToken(1);
	  if (tok.kind == EOF && ! g.contains(EOF) ) // fim da entrada?   
	      eof = true;
	}
    if ( tok != lastError)  {
	  System.out.println(e.getMessage());
	  lastError = tok;
	   
	}
	if ( eof )
	  throw new ParseEOFException("Encontrei EOF onde n\u00e3o deveria.");
  }
  
}

PARSER_END(Compilador)

SKIP :
{
  " "
| "\r"
| "\t"
| "\n"
}

TOKEN : {
    < IF : "sepato" >
  | < ELSE : "senaopato" >
  | < ELSEIF : "outropato" >
  | < WHILE : "repeteopato" >
  | < FOR : "paraopato" >
  | < INT : "patointeiro" >
  | < FLOAT : "patoreal" >
  | < STRING : "patoescrito" >
  | < ID : (["a"-"z"])+ >
  | < NUM : (["0"-"9"])+ ( "." (["0"-"9"])+ )? >
  | < ASSIGN : "=" >
  | < SEMICOLON : ";" >
  | < OPEN_CURLY : "fazisso{" >
  | < CLOSE_CURLY : "}" >
  | < OPEN_PAREN : "forassim(" >
  | < CLOSE_PAREN : ")entao" >
  | < COMMA : "," >
  | < EQUALS : "=ingual=" >
  | < AND : "&tambem&" > 
  | < OR : "|ouisso|" >
  | < LESS_THAN : "<" >
  | < GREATER_THAN : ">" >
  | < PLUS : "+" >
  | < MINUST : "-" >
  | < TIMES : "*" >
  | < DIVIDED : "/" > 
  | <EOF_TOKEN : "$php$">
}

void Semicolon() :
{/*@bgen(jjtree) Semicolon */
 SimpleNode jjtn000 = new SimpleNode(JJTSEMICOLON);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);
/*@egen*/RecoverySet sinc = First.semicolon;}
{/*@bgen(jjtree) Semicolon */
  try {
/*@egen*/
  try { 
	<SEMICOLON>
  } catch (ParseException e) {
	consumeUntil(sinc, e, "Semicolon");
  }/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void Identifier():
{/*@bgen(jjtree) Identifier */
 SimpleNode jjtn000 = new SimpleNode(JJTIDENTIFIER);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);
/*@egen*/RecoverySet sinc = First.identifier;}
{/*@bgen(jjtree) Identifier */
  try {
/*@egen*/
  try { 
  	< ID >
  } catch (ParseException e) {
	consumeUntil(sinc, e, "Identifier");
  }/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void Assign():
{/*@bgen(jjtree) Assign */
 SimpleNode jjtn000 = new SimpleNode(JJTASSIGN);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);
/*@egen*/RecoverySet sinc = First.assign;}
{/*@bgen(jjtree) Assign */
  try {
/*@egen*/
  try { 
  	< ASSIGN >
  } catch (ParseException e) {
	consumeUntil(sinc, e, "Assign");
  }/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void Comma():
{/*@bgen(jjtree) Comma */
 SimpleNode jjtn000 = new SimpleNode(JJTCOMMA);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);
/*@egen*/RecoverySet sinc = First.comma;}
{/*@bgen(jjtree) Comma */
  try {
/*@egen*/
  try { 
  	< COMMA >
   } catch (ParseException e) {
	consumeUntil(sinc, e, "Comma");
  }/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void OpenParen():
{/*@bgen(jjtree) OpenParen */
 SimpleNode jjtn000 = new SimpleNode(JJTOPENPAREN);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);
/*@egen*/RecoverySet sinc = First.openParen;}
{/*@bgen(jjtree) OpenParen */
  try {
/*@egen*/
  try { 
  	< OPEN_PAREN >
  } catch (ParseException e) {
	consumeUntil(sinc, e, "OpenParen");
  }/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void CloseParen():
{/*@bgen(jjtree) CloseParen */
 SimpleNode jjtn000 = new SimpleNode(JJTCLOSEPAREN);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);
/*@egen*/RecoverySet sinc = First.closeParen;}
{/*@bgen(jjtree) CloseParen */
  try {
/*@egen*/
  try { 
  	< CLOSE_PAREN >
  } catch (ParseException e) {
	consumeUntil(sinc, e, "CloseParen");
  }/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void OpenCurly():
{/*@bgen(jjtree) OpenCurly */
 SimpleNode jjtn000 = new SimpleNode(JJTOPENCURLY);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);
/*@egen*/RecoverySet sinc = First.openCurly;}
{/*@bgen(jjtree) OpenCurly */
  try {
/*@egen*/
  try { 
  	< OPEN_CURLY >
  } catch (ParseException e) {
	consumeUntil(sinc, e, "OpenCurly");
  }/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void CloseCurly():
{/*@bgen(jjtree) CloseCurly */
 SimpleNode jjtn000 = new SimpleNode(JJTCLOSECURLY);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);
/*@egen*/RecoverySet sinc = First.closeCurly;}
{/*@bgen(jjtree) CloseCurly */
  try {
/*@egen*/
  try { 
  	< CLOSE_CURLY >
   } catch (ParseException e) {
	consumeUntil(sinc, e, "CloseCurly");
  }/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void IfT():
{/*@bgen(jjtree) IfT */
 SimpleNode jjtn000 = new SimpleNode(JJTIFT);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);
/*@egen*/RecoverySet sinc = First.ifT;}
{/*@bgen(jjtree) IfT */
  try {
/*@egen*/
  try { 
  	< IF >
   } catch (ParseException e) {
	consumeUntil(sinc, e, "IfT");
  }/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void ElseT():
{/*@bgen(jjtree) ElseT */
 SimpleNode jjtn000 = new SimpleNode(JJTELSET);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);
/*@egen*/RecoverySet sinc = First.elseT;}
{/*@bgen(jjtree) ElseT */
   try {
/*@egen*/
   try { 
  	< ELSE >
   } catch (ParseException e) {
	consumeUntil(sinc, e, "ElseT");
  }/*@bgen(jjtree)*/
   } finally {
     if (jjtc000) {
       jjtree.closeNodeScope(jjtn000, true);
     }
   }
/*@egen*/
}

void ElseIfT():
{/*@bgen(jjtree) ElseIfT */
 SimpleNode jjtn000 = new SimpleNode(JJTELSEIFT);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);
/*@egen*/RecoverySet sinc = First.elseIfT;}
{/*@bgen(jjtree) ElseIfT */
  try {
/*@egen*/
  try { 
  	< ELSEIF >
  } catch (ParseException e) {
	consumeUntil(sinc, e, "ElseIfT");
  }/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void While():
{/*@bgen(jjtree) While */
 SimpleNode jjtn000 = new SimpleNode(JJTWHILE);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);
/*@egen*/RecoverySet sinc = First.whileT;}
{/*@bgen(jjtree) While */
  try {
/*@egen*/
  try { 
  	< WHILE >
   } catch (ParseException e) {
	consumeUntil(sinc, e, "WhileT");
  }/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void For():
{/*@bgen(jjtree) For */
 SimpleNode jjtn000 = new SimpleNode(JJTFOR);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);
/*@egen*/RecoverySet sinc = First.forT;}
{/*@bgen(jjtree) For */
  try {
/*@egen*/
  try { 
  	< FOR >
  } catch (ParseException e) {
	consumeUntil(sinc, e, "ForT");
  }/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void Int():
{/*@bgen(jjtree) Int */
 SimpleNode jjtn000 = new SimpleNode(JJTINT);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);
/*@egen*/RecoverySet sinc = First.intT;}
{/*@bgen(jjtree) Int */
  try {
/*@egen*/
  try { 
  	< INT >
  } catch (ParseException e) {
	consumeUntil(sinc, e, "IntT");
  }/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void Float():
{/*@bgen(jjtree) Float */
 SimpleNode jjtn000 = new SimpleNode(JJTFLOAT);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);
/*@egen*/RecoverySet sinc = First.floatT;}
{/*@bgen(jjtree) Float */
  try {
/*@egen*/
  try { 
  	< FLOAT >
   } catch (ParseException e) {
	consumeUntil(sinc, e, "FloatT");
  }/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void String():
{/*@bgen(jjtree) String */
 SimpleNode jjtn000 = new SimpleNode(JJTSTRING);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);
/*@egen*/RecoverySet sinc = First.stringT;}
{/*@bgen(jjtree) String */
   try {
/*@egen*/
   try {
  	< STRING >
   } catch (ParseException e) {
	consumeUntil(sinc, e, "StringT");
  }/*@bgen(jjtree)*/
   } finally {
     if (jjtc000) {
       jjtree.closeNodeScope(jjtn000, true);
     }
   }
/*@egen*/
}

void Or():
{/*@bgen(jjtree) Or */
 SimpleNode jjtn000 = new SimpleNode(JJTOR);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);
/*@egen*/RecoverySet sinc = First.or;}
{/*@bgen(jjtree) Or */
  try {
/*@egen*/
  try {
  	< OR >
  } catch (ParseException e) {
	consumeUntil(sinc, e, "Or");
  }/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void And():
{/*@bgen(jjtree) And */
 SimpleNode jjtn000 = new SimpleNode(JJTAND);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);
/*@egen*/RecoverySet sinc = First.and;}
{/*@bgen(jjtree) And */
  try {
/*@egen*/
  try {
  	< AND >
  } catch (ParseException e) {
	consumeUntil(sinc, e, "And");
  }/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void Equals():
{/*@bgen(jjtree) Equals */
 SimpleNode jjtn000 = new SimpleNode(JJTEQUALS);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);
/*@egen*/RecoverySet sinc = First.equals;}
{/*@bgen(jjtree) Equals */
  try {
/*@egen*/
  try { 
  	< EQUALS >
  } catch (ParseException e) {
	consumeUntil(sinc, e, "Equals");
  }/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void LessThan():
{/*@bgen(jjtree) LessThan */
 SimpleNode jjtn000 = new SimpleNode(JJTLESSTHAN);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);
/*@egen*/RecoverySet sinc = First.lessThan;}
{/*@bgen(jjtree) LessThan */
  try {
/*@egen*/
  try { 
  	< LESS_THAN >
  } catch (ParseException e) {
	consumeUntil(sinc, e, "LessThan");
  }/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void GreaterThan():
{/*@bgen(jjtree) GreaterThan */
 SimpleNode jjtn000 = new SimpleNode(JJTGREATERTHAN);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);
/*@egen*/RecoverySet sinc = First.greaterThan;}
{/*@bgen(jjtree) GreaterThan */
  try {
/*@egen*/
  try { 
  	< GREATER_THAN >
  } catch (ParseException e) {
	consumeUntil(sinc, e, "GreaterThan");
  }/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void Plus():
{/*@bgen(jjtree) Plus */
 SimpleNode jjtn000 = new SimpleNode(JJTPLUS);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);
/*@egen*/RecoverySet sinc = First.plus;}
{/*@bgen(jjtree) Plus */
  try {
/*@egen*/
  try { 
  	< PLUS >
  } catch (ParseException e) {
	consumeUntil(sinc, e, "Plus");
  }/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void Minus():
{/*@bgen(jjtree) Minus */
 SimpleNode jjtn000 = new SimpleNode(JJTMINUS);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);
/*@egen*/RecoverySet sinc = First.minus;}
{/*@bgen(jjtree) Minus */
  try {
/*@egen*/
  try { 
  	< MINUST >
  } catch (ParseException e) {
	consumeUntil(sinc, e, "Minus");
  }/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void Times():
{/*@bgen(jjtree) Times */
 SimpleNode jjtn000 = new SimpleNode(JJTTIMES);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);
/*@egen*/RecoverySet sinc = First.times;}
{/*@bgen(jjtree) Times */
  try {
/*@egen*/
  try { 
  	< TIMES >
  } catch (ParseException e) {
	consumeUntil(sinc, e, "Times");
  }/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void Divided():
{/*@bgen(jjtree) Divided */
 SimpleNode jjtn000 = new SimpleNode(JJTDIVIDED);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);
/*@egen*/RecoverySet sinc = First.divided;}
{/*@bgen(jjtree) Divided */
  try {
/*@egen*/
  try { 
  	< DIVIDED >
  } catch (ParseException e) {
	consumeUntil(sinc, e, "Divided");
  }/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void Number():
{/*@bgen(jjtree) Number */
 SimpleNode jjtn000 = new SimpleNode(JJTNUMBER);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);
/*@egen*/RecoverySet sinc = First.number;}
{/*@bgen(jjtree) Number */
  try {
/*@egen*/
  try { 
  	< NUM >
  } catch (ParseException e) {
	consumeUntil(sinc, e, "Number");
  }/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

SimpleNode Start() :
{/*@bgen(jjtree) Start */
 SimpleNode jjtn000 = new SimpleNode(JJTSTART);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);
/*@egen*/RecoverySet sinc = First.start;}
{/*@bgen(jjtree) Start */
  try {
/*@egen*/
  try { 
    (Statement())* <EOF_TOKEN>
    { return jjtn000; }
  } catch (ParseException e) {
	consumeUntil(sinc, e, "Start");
  }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void Statement() :
{/*@bgen(jjtree) Statement */
 SimpleNode jjtn000 = new SimpleNode(JJTSTATEMENT);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);
/*@egen*/RecoverySet sinc = First.statement;}
{/*@bgen(jjtree) Statement */
  try {
/*@egen*/
  try { 
    (VariableDeclaration() | Assignment() | Conditional() | Loop())
    (Semicolon())
   } catch (ParseException e) {
	 consumeUntil(sinc, e, "Statement");
   }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void VariableDeclaration() :
{/*@bgen(jjtree) VariableDeclaration */
 SimpleNode jjtn000 = new SimpleNode(JJTVARIABLEDECLARATION);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);
/*@egen*/RecoverySet sinc = First.variableDeclaration;}
{/*@bgen(jjtree) VariableDeclaration */
  try {
/*@egen*/
  try { 
    	Type() VariableDeclarations()
    } catch (ParseException e) {
	 consumeUntil(sinc, e, "VariableDeclaration");
   }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void VariableDeclarations() :
{/*@bgen(jjtree) VariableDeclarations */
 SimpleNode jjtn000 = new SimpleNode(JJTVARIABLEDECLARATIONS);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);
/*@egen*/RecoverySet sinc = First.variableDeclarations;}
{/*@bgen(jjtree) VariableDeclarations */
  try {
/*@egen*/
  try { 
    	Identifier() ((Assign() Expression()))? (Comma() Identifier() ((Assign() Expression()))?)*
	} catch (ParseException e) {
		 consumeUntil(sinc, e, "VariableDeclarations");
	   }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void MultiVariableAssignment() :
{/*@bgen(jjtree) MultiVariableAssignment */
 SimpleNode jjtn000 = new SimpleNode(JJTMULTIVARIABLEASSIGNMENT);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);
/*@egen*/RecoverySet sinc = First.multiVariableAssignment;}
{/*@bgen(jjtree) MultiVariableAssignment */
  try {
/*@egen*/
  try { 
    	(Comma() Identifier())* Assign() Expression()
    } catch (ParseException e) {
		 consumeUntil(sinc, e, "MultiVariableAssignment");
	}/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void Assignment() :
{/*@bgen(jjtree) Assignment */
 SimpleNode jjtn000 = new SimpleNode(JJTASSIGNMENT);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);
/*@egen*/RecoverySet sinc = First.assignment;}
{/*@bgen(jjtree) Assignment */
  try {
/*@egen*/
  try { 
    	Identifier() MultiVariableAssignment()
    } catch (ParseException e) {
		 consumeUntil(sinc, e, "Assignment");
	}/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void Conditional() :
{/*@bgen(jjtree) Conditional */
 SimpleNode jjtn000 = new SimpleNode(JJTCONDITIONAL);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);
/*@egen*/RecoverySet sinc = First.conditional;}
{/*@bgen(jjtree) Conditional */
  try {
/*@egen*/
  try { 
	    IfT() OpenParen() Expression() CloseParen() OpenCurly()
	    (Statement())*
	    CloseCurly()
	    (Else() | ElseIf())?
     } catch (ParseException e) {
		 consumeUntil(sinc, e, "Conditional");
	}/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void Else() :
{/*@bgen(jjtree) Else */
 SimpleNode jjtn000 = new SimpleNode(JJTELSE);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);
/*@egen*/RecoverySet sinc = First.elseNT;}
{/*@bgen(jjtree) Else */
  try {
/*@egen*/
  try { 
	    ElseT() OpenCurly()
	    (Statement())*
	    CloseCurly()
	    (Else() | ElseIf())?
     } catch (ParseException e) {
		 consumeUntil(sinc, e, "Else");
	}/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void ElseIf() :
{/*@bgen(jjtree) ElseIf */
 SimpleNode jjtn000 = new SimpleNode(JJTELSEIF);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);
/*@egen*/RecoverySet sinc = First.elseIf;}
{/*@bgen(jjtree) ElseIf */
  try {
/*@egen*/
  try { 
	    ElseIfT() OpenParen() Expression() CloseParen() OpenCurly()
	    (Statement())*
	    CloseCurly()
	    (Else() | ElseIf())?
    } catch (ParseException e) {
		 consumeUntil(sinc, e, "ElseIf");
	}/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}


void Loop() :
{/*@bgen(jjtree) Loop */
 SimpleNode jjtn000 = new SimpleNode(JJTLOOP);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);
/*@egen*/RecoverySet sinc = First.loop;}
{/*@bgen(jjtree) Loop */
  try {
/*@egen*/
  try { 
	    ( While() | For() ) OpenParen() Expression() CloseParen() OpenCurly()
	    (Statement())*
	    CloseCurly()
      } catch (ParseException e) {
		 consumeUntil(sinc, e, "Loop");
	}/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void Type() :
{/*@bgen(jjtree) Type */
 SimpleNode jjtn000 = new SimpleNode(JJTTYPE);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);
/*@egen*/RecoverySet sinc = First.type;}
{/*@bgen(jjtree) Type */
    try {
/*@egen*/
    try { 
    	( Int() | Float() | String())
    } catch (ParseException e) {
		 consumeUntil(sinc, e, "Type");
	}/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void Expression() :
{/*@bgen(jjtree) Expression */
 SimpleNode jjtn000 = new SimpleNode(JJTEXPRESSION);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);
/*@egen*/RecoverySet sinc = First.expression;}
{/*@bgen(jjtree) Expression */
    try {
/*@egen*/
    try { 
    	OrExpression() // Use a regra de or (ou)
    } catch (ParseException e) {
		 consumeUntil(sinc, e, "Expression");
	}/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void OrExpression() :
{/*@bgen(jjtree) OrExpression */
 SimpleNode jjtn000 = new SimpleNode(JJTOREXPRESSION);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);
/*@egen*/RecoverySet sinc = First.orExpression;}
{/*@bgen(jjtree) OrExpression */
        try {
/*@egen*/
  	try { 
    	AndExpression() ( Or() AndExpression() )*
    } catch (ParseException e) {
		 consumeUntil(sinc, e, "OrExpression");
	}/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void AndExpression() :
{/*@bgen(jjtree) AndExpression */
 SimpleNode jjtn000 = new SimpleNode(JJTANDEXPRESSION);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);
/*@egen*/RecoverySet sinc = First.andExpression;}
{/*@bgen(jjtree) AndExpression */
        try {
/*@egen*/
  	try { 
    	EqualityExpression() ( And() EqualityExpression() )*
    } catch (ParseException e) {
		 consumeUntil(sinc, e, "AndExpression");
	}/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void EqualityExpression() :
{/*@bgen(jjtree) EqualityExpression */
 SimpleNode jjtn000 = new SimpleNode(JJTEQUALITYEXPRESSION);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);
/*@egen*/RecoverySet sinc = First.equalityExpression;}
{/*@bgen(jjtree) EqualityExpression */
        try {
/*@egen*/
  	try { 
    	RelationalExpression() ( Equals() RelationalExpression() )*
  	} catch (ParseException e) {
		 consumeUntil(sinc, e, "EqualityExpression");
	}/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void RelationalExpression() :
{/*@bgen(jjtree) RelationalExpression */
 SimpleNode jjtn000 = new SimpleNode(JJTRELATIONALEXPRESSION);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);
/*@egen*/RecoverySet sinc = First.relationalExpression;}
{/*@bgen(jjtree) RelationalExpression */
        try {
/*@egen*/
  	try { 
    	AdditiveExpression() ( ( LessThan() | GreaterThan() ) AdditiveExpression() )*
	} catch (ParseException e) {
		 consumeUntil(sinc, e, "RelationalExpression");
	}/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void AdditiveExpression() :
{/*@bgen(jjtree) AdditiveExpression */
 SimpleNode jjtn000 = new SimpleNode(JJTADDITIVEEXPRESSION);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);
/*@egen*/RecoverySet sinc = First.additiveExpression;}
{/*@bgen(jjtree) AdditiveExpression */
        try {
/*@egen*/
  	try { 
    	Term() ( ( Plus() | Minus() ) Term() )*
    } catch (ParseException e) {
		 consumeUntil(sinc, e, "AdditiveExpression");
	}/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void Term() :
{/*@bgen(jjtree) Term */
 SimpleNode jjtn000 = new SimpleNode(JJTTERM);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);
/*@egen*/RecoverySet sinc = First.term;}
{/*@bgen(jjtree) Term */
        try {
/*@egen*/
 	try { 
   		Factor() ( ( Times() | Divided() ) Factor() )*
 	} catch (ParseException e) {
		 consumeUntil(sinc, e, "Term");
	}/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void Factor() :
{/*@bgen(jjtree) Factor */
 SimpleNode jjtn000 = new SimpleNode(JJTFACTOR);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);
/*@egen*/RecoverySet sinc = First.factor;}
{/*@bgen(jjtree) Factor */
        try {
/*@egen*/
  	try { 
    	Number() | Identifier() | OpenParen() Expression() CloseParen()
    } catch (ParseException e) {
		 consumeUntil(sinc, e, "Factor");
	}/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}